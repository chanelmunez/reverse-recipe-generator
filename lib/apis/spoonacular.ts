import type { Recipe, NutritionalProfile, CostBreakdown } from "@/types"

const API_KEY = process.env.SPOONACULAR_API_KEY
const API_BASE_URL = "https://api.spoonacular.com"

if (!API_KEY) {
  throw new Error("Spoonacular API key is not configured.")
}

interface SpoonacularAnalysis {
  extendedIngredients: { original: string }[]
  pricePerServing: number
  servings: number
  nutrition?: {
    // Make nutrition optional to handle API inconsistencies
    nutrients: { name: string; amount: number; unit: string }[]
  }
}

/**
 * Analyzes an AI-generated recipe using the Spoonacular API.
 * @param {Recipe} recipe - The recipe object generated by the AI.
 * @param {string[]} debugLog - An array to push debug messages to.
 * @returns {Promise<{recipe: Recipe; nutritionalProfile: NutritionalProfile; costBreakdown: CostBreakdown}>}
 */
export async function analyzeRecipeWithSpoonacular(
  recipe: Recipe,
  debugLog: string[],
): Promise<{ recipe: Recipe; nutritionalProfile: NutritionalProfile; costBreakdown: CostBreakdown }> {
  debugLog.push(`[Spoonacular] Analyzing recipe: "${recipe.name}"`)

  // FIX: Added includeNutrition=true to the query parameters
  const analyzeUrl = `${API_BASE_URL}/recipes/analyze?apiKey=${API_KEY}&includeNutrition=true`

  const response = await fetch(analyzeUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      title: recipe.name,
      ingredients: recipe.ingredients.map((ing) => `${ing.amount} ${ing.name}`),
      instructions: recipe.steps.join("\n"),
    }),
  })

  if (!response.ok) {
    const errorBody = await response.text()
    throw new Error(`Spoonacular recipe analysis failed: ${errorBody}`)
  }

  const analysis: SpoonacularAnalysis = await response.json()
  debugLog.push(`[Spoonacular] Analysis successful. Found ${analysis.extendedIngredients.length} ingredients.`)

  const finalRecipe: Recipe = {
    ...recipe,
    ingredients: analysis.extendedIngredients.map((ing) => ({ name: ing.original, amount: "" })),
  }

  // FIX: Add defensive coding with optional chaining and default to an empty array
  const nutrients = analysis.nutrition?.nutrients || []
  if (nutrients.length === 0) {
    debugLog.push("[Spoonacular] Warning: Nutrition data was not returned in the analysis.")
  }

  const nutritionalProfile: NutritionalProfile = {
    calories: nutrients.find((n) => n.name === "Calories")?.amount || 0,
    protein: nutrients.find((n) => n.name === "Protein")?.amount || 0,
    fat: nutrients.find((n) => n.name === "Fat")?.amount || 0,
    carbohydrates: nutrients.find((n) => n.name === "Carbohydrates")?.amount || 0,
  }

  const costBreakdown: CostBreakdown = {
    perServing: analysis.pricePerServing / 100,
    totalCost: (analysis.pricePerServing / 100) * (analysis.servings || 1),
  }

  return { recipe: finalRecipe, nutritionalProfile, costBreakdown }
}
